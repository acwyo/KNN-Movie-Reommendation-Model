# -*- coding: utf-8 -*-
"""KNN for movie recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kA3squDXD8imXXBb3OMR761wL_3oTFje

TMDB Score Prediction and Movie Recommendation

![](data:image/jpeg;base64,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)

Recommendation systems are becoming increasingly important in today’s hectic world. People are always in the lookout for products/services that are best suited for them. Therefore, the recommendation systems are important as they help them make the right choices, without having to expend their cognitive resources.

In this kernel, I will build a Movie Recommendation System using collaborative filtering by implementing the K-Nearest Neighbors algorithm. I will also predict the rating of the given movie based on its neighbors and compare it with the actual rating.

Check out my [blog](https://medium.com/swlh/movie-recommendation-and-rating-prediction-using-k-nearest-neighbors-704ca8ccaff3) for a better understanding

### **Import the required Python libraries**
"""

import pandas as pd
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import seaborn as sns
import numpy as np
import json
import warnings
warnings.filterwarnings('ignore')
import base64
import io
from matplotlib.pyplot import imread
import codecs
from IPython.display import HTML

"""### **Import the dataset**

1. tmdb_5000_movies.csv: Contains information like the score, title, date_of_release, genres, etc.
2. tmdb_5000_credits.csv: Contains information of the cast and crew for each movie.
"""

from google.colab import files


uploaded = files.upload()

import pandas as pd
import io

movies = pd.read_csv(io.BytesIO(uploaded['tmdb_5000_movies.csv']))
#print(movies)
credits = pd.read_csv(io.BytesIO(uploaded['tmdb_5000_credits.csv']))
#print(credits)

#movies = pd.read_csv('../input/tmdb-movie-metadata/tmdb_5000_movies.csv')
#credits = pd.read_csv('../input/tmdb-movie-metadata/tmdb_5000_credits.csv')

"""## **Data Exploration & Cleaning**

use the head(), describe() function to view the values and structure of the dataset, and then move ahead with cleaning the data.
"""

movies.head()

movies.describe()

credits.head()

credits.describe()

"""Checking the dataset, we can see that genres, keywords, production_companies, production_countries, spoken_languages are in the JSON format.
Similarly in the other CSV file, cast and crew are in the JSON format. Now convert these columns into strings and later convert them into lists for easier interpretation.

**Converting JSON into strings**
"""

# changing the genres column from json to string
movies['genres'] = movies['genres'].apply(json.loads)
for index,i in zip(movies.index,movies['genres']):
    list1 = []
    for j in range(len(i)):
        list1.append((i[j]['name'])) # the key 'name' contains the name of the genre
    movies.loc[index,'genres'] = str(list1)

# changing the keywords column from json to string
movies['keywords'] = movies['keywords'].apply(json.loads)
for index,i in zip(movies.index,movies['keywords']):
    list1 = []
    for j in range(len(i)):
        list1.append((i[j]['name']))
    movies.loc[index,'keywords'] = str(list1)

# changing the production_companies column from json to string
movies['production_companies'] = movies['production_companies'].apply(json.loads)
for index,i in zip(movies.index,movies['production_companies']):
    list1 = []
    for j in range(len(i)):
        list1.append((i[j]['name']))
    movies.loc[index,'production_companies'] = str(list1)

# changing the cast column from json to string
credits['cast'] = credits['cast'].apply(json.loads)
for index,i in zip(credits.index,credits['cast']):
    list1 = []
    for j in range(len(i)):
        list1.append((i[j]['name']))
    credits.loc[index,'cast'] = str(list1)

# changing the crew column from json to string
credits['crew'] = credits['crew'].apply(json.loads)
def director(x):
    for i in x:
        if i['job'] == 'Director':
            return i['name']
credits['crew'] = credits['crew'].apply(director)
credits.rename(columns={'crew':'director'},inplace=True)

movies.head()

"""In a similar fashion, we will convert the JSON to a list of strings for the columns: keywords, production_companies, cast, and crew. We will check if all the required JSON columns have been converted to strings using movies.iloc[index]"""

movies.iloc[25]

"""## **Merging the two csv files**

merge the movies and credits dataframes and select the columns which are required and have a unified movies dataframe to work on.
"""

movies = movies.merge(credits,left_on='id',right_on='movie_id',how='left')
movies = movies[['id','original_title','genres','cast','vote_average','director','keywords']]

movies.iloc[25]

movies.shape

"""check the size and attributes of movies"""

movies.size

movies.index

movies.columns

movies.dtypes

"""## **Working with the Genres column**

clean the genre column to find the genre_list
"""

movies['genres'] = movies['genres'].str.strip('[]').str.replace(' ','').str.replace("'",'')
movies['genres'] = movies['genres'].str.split(',')

"""**plot the genres in terms of their occurrence to get an insight into movie genres in terms of popularity.**"""

plt.subplots(figsize=(12,10))
list1 = []
for i in movies['genres']:
    list1.extend(i)
ax = pd.Series(list1).value_counts()[:10].sort_values(ascending=True).plot.barh(width=0.9,color=sns.color_palette('hls',10))
for i, v in enumerate(pd.Series(list1).value_counts()[:10].sort_values(ascending=True).values):
    ax.text(.8, i, v,fontsize=12,color='white',weight='bold')
plt.title('Top Genres')
plt.show()

"""Drama appears to be the most popular genre followed by Comedy."""

for i,j in zip(movies['genres'],movies.index):
    list2=[]
    list2=i
    list2.sort()
    movies.loc[j,'genres']=str(list2)
movies['genres'] = movies['genres'].str.strip('[]').str.replace(' ','').str.replace("'",'')
movies['genres'] = movies['genres'].str.split(',')

"""generate a list 'genreList' with all possible unique genres mentioned in the dataset.


"""

genreList = []
for index, row in movies.iterrows():
    genres = row["genres"]

    for genre in genres:
        if genre not in genreList:
            genreList.append(genre)
genreList[:10] #now we have a list with unique genres

"""**One Hot Encoding for multiple labels**

‘genreList’ will now hold all the genres. But how do we come to know about the genres each movie falls into. Now some movies will be ‘Action’, some will be ‘Action, Adventure’, etc. We need to classify the movies according to their genres.

Let’s create a new column in the dataframe that will hold the binary values whether a genre is present or not in it. First, let’s create a method that will return back a list of binary values for the genres of each movie. The ‘genreList’ will be useful now to compare against the values.

Let’s say for example we have 20 unique genres in the list. Thus the below function will return a list with 20 elements, which will be either 0 or 1. Now for example we have a Movie which has genre = ‘Action’, then the new column will hold [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].

Similarly for ‘Action, Adventure’ we will have, [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]. Converting the genres into such a list of binary values will help in easily classifying the movies by their genres.
"""

def binary(genre_list):
    binaryList = []

    for genre in genreList:
        if genre in genre_list:
            binaryList.append(1)
        else:
            binaryList.append(0)

    return binaryList

"""Applying the binary() function to the ‘genres’ column to get ‘genre_list’

We will follow the same notations for other features like the cast, director, and the keywords.
"""

movies['genres_bin'] = movies['genres'].apply(lambda x: binary(x))
movies['genres_bin'].head()

"""## **Working with the Cast Column**

plot a graph of Actors with Highest Appearances
"""

movies['cast'] = movies['cast'].str.strip('[]').str.replace(' ','').str.replace("'",'').str.replace('"','')
movies['cast'] = movies['cast'].str.split(',')

"""Samuel Jackson aka Nick Fury from Avengers has appeared in maximum movies.

When initially created the list of all the cast, it had around 50k unique values, as many movies have entries for about 15–20 actors. But we just need the actors who have the highest contribution to the movie.

For eg: The Dark Knight franchise has many actors involved in the movie. But we will select only the main actors like Christian Bale, Micheal Caine, Heath Ledger. Select the main 4 actors from each movie.

How do we determine the importance of the actor in the movie? The sequence of the actors in the JSON format is according to the actor’s contribution to the movie.

create a column ‘cast_bin’
"""

plt.subplots(figsize=(12,10))
list1=[]
for i in movies['cast']:
    list1.extend(i)
ax=pd.Series(list1).value_counts()[:15].sort_values(ascending=True).plot.barh(width=0.9,color=sns.color_palette('muted',40))
for i, v in enumerate(pd.Series(list1).value_counts()[:15].sort_values(ascending=True).values):
    ax.text(.8, i, v,fontsize=10,color='white',weight='bold')
plt.title('Actors with highest appearance')
plt.show()

for i,j in zip(movies['cast'],movies.index):
    list2 = []
    list2 = i[:4]
    movies.loc[j,'cast'] = str(list2)
movies['cast'] = movies['cast'].str.strip('[]').str.replace(' ','').str.replace("'",'')
movies['cast'] = movies['cast'].str.split(',')
for i,j in zip(movies['cast'],movies.index):
    list2 = []
    list2 = i
    list2.sort()
    movies.loc[j,'cast'] = str(list2)
movies['cast']=movies['cast'].str.strip('[]').str.replace(' ','').str.replace("'",'')

castList = []
for index, row in movies.iterrows():
    cast = row["cast"]

    for i in cast:
        if i not in castList:
            castList.append(i)

def binary(cast_list):
    binaryList = []

    for genre in castList:
        if genre in cast_list:
            binaryList.append(1)
        else:
            binaryList.append(0)

    return binaryList

movies['cast_bin'] = movies['cast'].apply(lambda x: binary(x))
movies['cast_bin'].head()

"""## **Working with Director column**

Let’s plot Directors with maximum movies
"""

def xstr(s):
    if s is None:
        return ''
    return str(s)
movies['director'] = movies['director'].apply(xstr)

plt.subplots(figsize=(12,10))
ax = movies[movies['director']!=''].director.value_counts()[:10].sort_values(ascending=True).plot.barh(width=0.9,color=sns.color_palette('muted',40))
for i, v in enumerate(movies[movies['director']!=''].director.value_counts()[:10].sort_values(ascending=True).values):
    ax.text(.5, i, v,fontsize=12,color='white',weight='bold')
plt.title('Directors with highest movies')
plt.show()

"""create a new column ‘director_bin’ as we have done earlier"""

directorList=[]
for i in movies['director']:
    if i not in directorList:
        directorList.append(i)

def binary(director_list):
    binaryList = []
    for direct in directorList:
        if direct in director_list:
            binaryList.append(1)
        else:
            binaryList.append(0)
    return binaryList

"""**FINAL MOVIES DATASET**"""

movies['director_bin'] = movies['director'].apply(lambda x: binary(x))
movies.head()

"""## **Working with the Keywords column**

The keywords or tags contain a lot of information about the movie, and it is a key feature in finding similar movies.

For eg: Movies like “Avengers” and “Ant-man” may have common keywords like superheroes or Marvel.

For analyzing keywords, we will try something different and plot a word cloud to get a better intuition:
"""

from wordcloud import WordCloud, STOPWORDS
import nltk
nltk.download('stopwords')
nltk.download('punkt')
from nltk.corpus import stopwords

plt.subplots(figsize=(12,12))
stop_words = set(stopwords.words('english'))
stop_words.update(',',';','!','?','.','(',')','$','#','+',':','...',' ','')

words=movies['keywords'].dropna().apply(nltk.word_tokenize)
word=[]
for i in words:
    word.extend(i)
word=pd.Series(word)
word=([i for i in word.str.lower() if i not in stop_words])
wc = WordCloud(background_color="black", max_words=2000, stopwords=STOPWORDS, max_font_size= 60,width=1000,height=1000)
wc.generate(" ".join(word))
plt.imshow(wc)
plt.axis('off')
fig=plt.gcf()
fig.set_size_inches(10,10)
plt.show()

"""Above is a wordcloud showing the major keywords or tags used for describing the movies.

We find ‘words_bin’ from Keywords as follows —
"""

movies['keywords'] = movies['keywords'].str.strip('[]').str.replace(' ','').str.replace("'",'').str.replace('"','')
movies['keywords'] = movies['keywords'].str.split(',')
for i,j in zip(movies['keywords'],movies.index):
    list2 = []
    list2 = i
    movies.loc[j,'keywords'] = str(list2)
movies['keywords'] = movies['keywords'].str.strip('[]').str.replace(' ','').str.replace("'",'')
movies['keywords'] = movies['keywords'].str.split(',')
for i,j in zip(movies['keywords'],movies.index):
    list2 = []
    list2 = i
    list2.sort()
    movies.loc[j,'keywords'] = str(list2)
movies['keywords'] = movies['keywords'].str.strip('[]').str.replace(' ','').str.replace("'",'')
movies['keywords'] = movies['keywords'].str.split(',')

words_list = []
for index, row in movies.iterrows():
    genres = row["keywords"]

    for genre in genres:
        if genre not in words_list:
            words_list.append(genre)

def binary(words):
    binaryList = []
    for genre in words_list:
        if genre in words:
            binaryList.append(1)
        else:
            binaryList.append(0)
    return binaryList

movies['words_bin'] = movies['keywords'].apply(lambda x: binary(x))
movies = movies[(movies['vote_average']!=0)] #removing the movies with 0 score and without drector names
movies = movies[movies['director']!='']

"""## Similarity between movies

![image.png](data:image/png;base64,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)

We will be using Cosine Similarity for finding the similarity between 2 movies. How does cosine similarity work?

Let’s say we have 2 vectors. If the vectors are close to parallel, i.e. angle between the vectors is 0, then we can say that both of them are “similar”, as cos(0)=1. Whereas if the vectors are orthogonal, then we can say that they are independent or NOT “similar”, as cos(90)=0.

defined a function Similarity, which will check the similarity between the movies.
"""

from scipy import spatial

def Similarity(movieId1, movieId2):
    a = movies.iloc[movieId1]
    b = movies.iloc[movieId2]

    genresA = a['genres_bin']
    genresB = b['genres_bin']

    genreDistance = spatial.distance.cosine(genresA, genresB)

    scoreA = a['cast_bin']
    scoreB = b['cast_bin']
    scoreDistance = spatial.distance.cosine(scoreA, scoreB)

    directA = a['director_bin']
    directB = b['director_bin']
    directDistance = spatial.distance.cosine(directA, directB)

    wordsA = a['words_bin']
    wordsB = b['words_bin']
    wordsDistance = spatial.distance.cosine(directA, directB)
    return genreDistance + directDistance + scoreDistance + wordsDistance

"""check the Similarity between 2 random movies"""

Similarity(3,160) #checking similarity between any 2 random movies

"""We see that the distance is about 2.068, which is high. The more the distance, the less similar the movies are. Let's see what these random movies actually were."""

print(movies.iloc[3])
print(movies.iloc[160])

"""It is evident that The Dark Knight Rises and How to train your Dragon 2 are very different movies. Thus the distance is huge.


"""

new_id = list(range(0,movies.shape[0]))
movies['new_id']=new_id
movies=movies[['original_title','genres','vote_average','genres_bin','cast_bin','new_id','director','director_bin','words_bin']]
movies.head()

"""## **Score Predictor**

So now when we have everything in place, we will now build the score predictor. The main function working under the hood will be the Similarity() function, which will calculate the similarity between movies, and will find 10 most similar movies. These 10 movies will help in predicting the score for our desired movie. We will take the average of the scores of similar movies and find the score for the desired movie.

Now the similarity between the movies will depend on our newly created columns containing binary lists. We know that features like the director or the cast will play a very important role in the movie’s success. We always assume that movies from David Fincher or Chris Nolan will fare very well. Also if they work with their favorite actors, who always fetch them success and also work on their favorite genres, then the chances of success are even higher. Using these phenomena, let’s try building our score predictor.
"""

import operator

def predict_score(name):
    #name = input('Enter a movie title: ')
    new_movie = movies[movies['original_title'].str.contains(name)].iloc[0].to_frame().T
    print('Selected Movie: ',new_movie.original_title.values[0])
    def getNeighbors(baseMovie, K):
        distances = []

        for index, movie in movies.iterrows():
            if movie['new_id'] != baseMovie['new_id'].values[0]:
                dist = Similarity(baseMovie['new_id'].values[0], movie['new_id'])
                distances.append((movie['new_id'], dist))

        distances.sort(key=operator.itemgetter(1))
        neighbors = []

        for x in range(K):
            neighbors.append(distances[x])
        return neighbors

    K = 1
    avgRating = 0
    neighbors = getNeighbors(new_movie, K)

    print('\nRecommended Movies: \n')
    for neighbor in neighbors:
        avgRating = avgRating+movies.iloc[neighbor[0]][2]
        print( movies.iloc[neighbor[0]][0]+" | Genres: "+str(movies.iloc[neighbor[0]][1]).strip('[]').replace(' ','')+" | Rating: "+str(movies.iloc[neighbor[0]][2]))

    print('\n')
    avgRating = avgRating/K
    print('The predicted rating for %s is: %f' %(new_movie['original_title'].values[0],avgRating))
    print('The actual rating for %s is %f' %(new_movie['original_title'].values[0],new_movie['vote_average']))

predict_score('Godfather')

predict_score('Donnie Darko')

predict_score('Notting Hill')

predict_score('Despicable Me')

predict_score('Jurassic World')

predict_score('Avatar')

"""##Sidenote — K Value
In this project, the value K=10.

But in other applications of KNN, finding the value of K is not easy. A small value of K means that noise will have a higher influence on the result and a large value make it computationally expensive. Data scientists usually choose as an odd number if the number of classes is 2 and another simple approach to select k is set K=sqrt(n).

# Parameter Changing - K
"""

def get_similarity(k, name):
  new_movie = movies[movies['original_title'].str.contains(name)].iloc[0].to_frame().T
  print(new_movie.original_title.values[0])
  def getNeighbors(baseMovie, K):
      distances = []

      for index, movie in movies.iterrows():
          if movie['new_id'] != baseMovie['new_id'].values[0]:
              dist = Similarity(baseMovie['new_id'].values[0], movie['new_id'])
              distances.append((movie['new_id'], dist))

      distances.sort(key=operator.itemgetter(1))
      neighbors = []

      for x in range(K):
          neighbors.append(distances[x])
      return neighbors

  #K, number of neighbours
  K = k
  avgRating = 0
  neighbors = getNeighbors(new_movie, K)

  for neighbor in neighbors:
      avgRating = avgRating+movies.iloc[neighbor[0]][2]

  avgRating = avgRating/K
  return avgRating

movies.loc[:,'k1'] = get_similarity(movies['original_title'])

movies.head()

movies.shape

movies.iloc[:3,:]

cosine_movies = movies.iloc[:50, :]

cosine_movies.shape

cosine_movies

k1 = []
for i in range(50):
  predict_score = get_similarity(cosine_movies.original_title[i])
  k1.append(predict_score)
cosine_movies["k1"]=k1

k2 = []
for i in range(50):
  predict_score = get_similarity(2, cosine_movies.original_title[i])
  k2.append(predict_score)
cosine_movies["k2"]=k2

k3 = []
for i in range(50):
  predict_score = get_similarity(3, cosine_movies.original_title[i])
  k3.append(predict_score)
cosine_movies["k3"]=k3

cosine_movies